name: Container File Update and Management

on:
  schedule:
    - cron: '0 4 * * *' # Daily at 4 AM UTC
  workflow_dispatch:
    inputs:
      update_type:
        description: 'Type of container update'
        required: true
        type: choice
        options: [dockerfiles, compose-files, kubernetes-manifests, helm-charts, all-containers]
        default: 'all-containers'
      base_image_update:
        description: 'Update base images to latest versions'
        required: false
        type: boolean
        default: true
      security_scan:
        description: 'Perform security scanning'
        required: false
        type: boolean
        default: true
      create_pr:
        description: 'Create pull request with updates'
        required: false
        type: boolean
        default: true
      registry:
        description: 'Container registry to use'
        required: false
        type: choice
        options: [docker.io, ghcr.io, quay.io, gcr.io]
        default: 'docker.io'
  push:
    paths:
      - 'Dockerfile*'
      - 'docker-compose*.yml'
      - 'docker-compose*.yaml'
      - 'k8s/**/*.yml'
      - 'k8s/**/*.yaml'
      - 'kubernetes/**/*.yml'
      - 'kubernetes/**/*.yaml'
      - 'helm/**/*.yml'
      - 'helm/**/*.yaml'

permissions:
  contents: write
  pull-requests: write
  security-events: write

jobs:
  container-file-update:
    runs-on: ubuntu-latest

    # 입력이 없는 schedule/push 에서도 안정적으로 동작하도록 기본값 환경변수로 정규화
    env:
      UPDATE_TYPE: ${{ inputs.update_type || 'all-containers' }}
      BASE_IMAGE_UPDATE: ${{ (inputs.base_image_update != '' && inputs.base_image_update) || true }}
      SECURITY_SCAN: ${{ (inputs.security_scan != '' && inputs.security_scan) || true }}
      CREATE_PR: ${{ (inputs.create_pr != '' && inputs.create_pr) || true }}
      REGISTRY: ${{ inputs.registry || 'docker.io' }}

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Echo helpers (TS/echoe/warn/fail) + shell strict mode
        id: echo_helpers
        run: |
          set -Eeuo pipefail
          cat > /tmp/echo_helpers.sh <<'SH'
          set -Eeuo pipefail
          TS()   { date -u +"%Y-%m-%dT%H:%M:%SZ"; }
          echoe(){ printf "[%s] %s\n" "$(TS)" "$*"; }
          warn() { printf "[%s] [WARN] %s\n" "$(TS)" "$*" >&2; }
          fail() { printf "[%s] [FAIL] %s\n" "$(TS)" "$*" >&2; exit 1; }
          retry(){ # retry <n> <cmd...>
            local n=$1; shift
            local i=1
            until "$@"; do
              if [ $i -ge "$n" ]; then return 1; fi
              warn "retry $i/$n for: $*"
              sleep $((i*2))
              i=$((i+1))
            done
          }
          SH
          source /tmp/echo_helpers.sh
          echoe "Echo helpers installed"
          echo "helpers=/tmp/echo_helpers.sh" >> $GITHUB_OUTPUT

      - name: Print normalized inputs
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "UPDATE_TYPE      = ${{ env.UPDATE_TYPE }}"
          echoe "BASE_IMAGE_UPDATE= ${{ env.BASE_IMAGE_UPDATE }}"
          echoe "SECURITY_SCAN    = ${{ env.SECURITY_SCAN }}"
          echoe "CREATE_PR        = ${{ env.CREATE_PR }}"
          echoe "REGISTRY         = ${{ env.REGISTRY }}"

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Install container tooling (compose/helm/kubectl/jq) with retries
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Installing Docker Compose"
          retry 3 bash -c 'sudo curl -fsSL "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose'
          sudo chmod +x /usr/local/bin/docker-compose
          /usr/local/bin/docker-compose version || warn "compose version check failed"

          echoe "Installing Helm"
          retry 3 bash -c 'curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash'

          echoe "Installing kubectl"
          KREL="$(retry 3 bash -c "curl -fsSL https://dl.k8s.io/release/stable.txt")"
          retry 3 bash -c "curl -fsSL https://dl.k8s.io/release/${KREL}/bin/linux/amd64/kubectl -o kubectl"
          sudo install -o root -g root -m 0755 kubectl /usr/local/bin/kubectl
          kubectl version --client=true || warn "kubectl version failed"

          echoe "Installing jq"
          sudo apt-get update -y
          sudo apt-get install -y jq

          echoe "Installing Python deps"
          python -m pip install --upgrade pip
          pip install pyyaml jinja2 requests semver

      - name: Create container management directories
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          set -Eeuo pipefail
          echoe "Creating directories"
          mkdir -p container-management/{tools,templates,configs,reports,updates}
          mkdir -p container-management/backups/{dockerfiles,compose,kubernetes,helm}

      - name: Add container file analyzer (echo logs inside)
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Writing analyzer script"
          cat > container-management/tools/container-analyzer.py << 'EOF'
          #!/usr/bin/env python3
          import os, yaml, json, logging
          from pathlib import Path
          from datetime import datetime

          logging.basicConfig(level=logging.INFO, format='[%(asctime)s] %(levelname)s: %(message)s')
          log = logging.getLogger("analyzer")

          class Analyzer:
              def __init__(self, registry="docker.io"):
                  self.registry = registry
                  self.root = Path.cwd()
                  self.out = {
                      "dockerfiles": [], "compose_files": [], "kubernetes_manifests": [], "helm_charts": [],
                      "summary": {"total_files": 0, "outdated_images": 0, "security_issues": 0, "recommendations": []},
                      "meta": {"registry": registry, "generated_at": datetime.utcnow().isoformat()+"Z"}
                  }

              def _echo(self, msg): log.info(msg)

              def scan(self):
                  self._echo("Scanning repository for container files")
                  for p in self.root.rglob("Dockerfile*"):
                      if p.is_file(): self.out["dockerfiles"].append({"file": str(p)})
                  for pat in ("docker-compose*.yml","docker-compose*.yaml"):
                      for p in self.root.rglob(pat): self.out["compose_files"].append({"file": str(p)})
                  for p in self.root.rglob("*.yml"):
                      if any(x in str(p) for x in ("k8s","kubernetes","manifests")): self.out["kubernetes_manifests"].append({"file": str(p)})
                  for p in self.root.rglob("*.yaml"):
                      if any(x in str(p) for x in ("k8s","kubernetes","manifests")): self.out["kubernetes_manifests"].append({"file": str(p)})
                  for p in self.root.rglob("Chart.yaml"): self.out["helm_charts"].append({"file": str(p)})
                  self.out["summary"]["total_files"] = sum(len(self.out[k]) for k in ("dockerfiles","compose_files","kubernetes_manifests","helm_charts"))
                  self._echo(f"Found {self.out['summary']['total_files']} container-related files")
                  return self.out

          if __name__ == "__main__":
              import argparse
              ap = argparse.ArgumentParser()
              ap.add_argument("--registry", default="docker.io")
              ap.add_argument("--output", default="container-management/reports/container-analysis.json")
              args = ap.parse_args()
              a = Analyzer(registry=args.registry)
              res = a.scan()
              Path(args.output).parent.mkdir(parents=True, exist_ok=True)
              with open(args.output, "w") as f: json.dump(res, f, indent=2)
              print(f"Analysis complete: {args.output}")
          EOF
          chmod +x container-management/tools/container-analyzer.py
          echoe "Analyzer script ready"

      - name: Create secure templates (Dockerfile/Compose/K8s) with echo comments
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Writing templates"
          cat > container-management/templates/Dockerfile.modern << 'EOF'
          # echo: multi-stage, non-root, healthcheck
          FROM node:18-alpine AS builder
          RUN addgroup -g 1001 -S nodejs && adduser -S nextjs -u 1001
          WORKDIR /app
          COPY package*.json ./
          RUN npm ci --only=production && npm cache clean --force
          COPY --chown=nextjs:nodejs . .
          RUN npm run build

          FROM node:18-alpine AS runner
          RUN addgroup -g 1001 -S nodejs && adduser -S nextjs -u 1001
          WORKDIR /app
          COPY --from=builder --chown=nextjs:nodejs /app ./
          USER nextjs
          EXPOSE 3000
          HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 CMD curl -f http://localhost:3000/health || exit 1
          CMD ["npm","start"]
          EOF

          cat > container-management/templates/docker-compose.secure.yml << 'EOF'
          version: '3.8'
          services:
            web:
              build: { context: ., dockerfile: Dockerfile }
              ports: ["3000:3000"]
              environment: [ NODE_ENV=production ]
              restart: unless-stopped
              security_opt: [ "no-new-privileges:true" ]
              cap_drop: [ "ALL" ]
              cap_add:  [ "CHOWN","SETGID","SETUID" ]
              read_only: true
              tmpfs: [ "/tmp" ]
              volumes: [ "./logs:/app/logs:rw" ]
              networks: [ app-network ]
              healthcheck:
                test: ["CMD","curl","-f","http://localhost:3000/health"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s

            database:
              image: postgres:15-alpine
              environment:
                POSTGRES_DB: app_db
                POSTGRES_USER: app_user
                POSTGRES_PASSWORD_FILE: /run/secrets/db_password
              volumes:
                - postgres_data:/var/lib/postgresql/data
                - ./init.sql:/docker-entrypoint-initdb.d/init.sql:ro
              networks: [ app-network ]
              restart: unless-stopped
              security_opt: [ "no-new-privileges:true" ]
              cap_drop: [ "ALL" ]
              cap_add:  [ "CHOWN","SETGID","SETUID" ]
              secrets: [ db_password ]

          volumes: { postgres_data: {} }
          networks: { app-network: { driver: bridge } }
          secrets: { db_password: { file: ./secrets/db_password.txt } }
          EOF

          cat > container-management/templates/k8s-deployment.secure.yaml << 'EOF'
          apiVersion: apps/v1
          kind: Deployment
          metadata:
            name: secure-app
            labels: { app: secure-app, version: v1.0.0 }
          spec:
            replicas: 3
            selector: { matchLabels: { app: secure-app } }
            template:
              metadata: { labels: { app: secure-app } }
              spec:
                securityContext: { runAsNonRoot: true, runAsUser: 1001, runAsGroup: 1001, fsGroup: 1001 }
                containers:
                - name: app
                  image: myapp:latest
                  ports: [ { containerPort: 3000 } ]
                  securityContext:
                    allowPrivilegeEscalation: false
                    readOnlyRootFilesystem: true
                    capabilities: { drop: [ "ALL" ] }
                  resources:
                    requests: { memory: "128Mi", cpu: "100m" }
                    limits:   { memory: "256Mi", cpu: "200m" }
                  livenessProbe:  { httpGet: { path: /health, port: 3000 }, initialDelaySeconds: 30, periodSeconds: 10 }
                  readinessProbe: { httpGet: { path: /ready,  port: 3000 }, initialDelaySeconds: 5,  periodSeconds: 5  }
                  volumeMounts:
                    - { name: tmp-volume,   mountPath: /tmp }
                    - { name: cache-volume, mountPath: /app/cache }
                volumes:
                  - { name: tmp-volume,   emptyDir: {} }
                  - { name: cache-volume, emptyDir: {} }
          EOF
          echoe "Templates ready"

      - name: Run container analysis (echo)
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Running analyzer"
          python container-management/tools/container-analyzer.py \
            --registry "${{ env.REGISTRY }}" \
            --output "container-management/reports/container-analysis-$(date +%Y%m%d).json"
          echoe "Analyzer done"

      - name: Create container update script (echo-rich) and execute
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Writing update script"
          cat > container-management/tools/update-containers.sh <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          source /tmp/echo_helpers.sh

          UPDATE_TYPE="${UPDATE_TYPE:-all-containers}"
          BASE_IMAGE_UPDATE="${BASE_IMAGE_UPDATE:-true}"
          TS_UTC=$(TS)
          BKDIR="container-management/backups/$(date +%Y%m%d)"

          echoe "=== Container File Update Process ==="
          echoe "UPDATE_TYPE       : ${UPDATE_TYPE}"
          echoe "BASE_IMAGE_UPDATE : ${BASE_IMAGE_UPDATE}"
          echoe "START             : ${TS_UTC}"

          echoe "Creating backup dir: ${BKDIR}"
          mkdir -p "${BKDIR}"

          echoe "Backing up Dockerfiles / Compose files (if any)"
          find . -name "Dockerfile*" -type f -print -exec cp {} "${BKDIR}/" \; || true
          find . -name "docker-compose*.yml"  -type f -print -exec cp {} "${BKDIR}/" \; || true
          find . -name "docker-compose*.yaml" -type f -print -exec cp {} "${BKDIR}/" \; || true

          if [ ! -f Dockerfile ]; then
            echoe "No Dockerfile found → creating sample modern Dockerfile"
            cp container-management/templates/Dockerfile.modern Dockerfile
          fi

          if [ ! -f docker-compose.yml ]; then
            echoe "No docker-compose.yml found → creating secure template"
            cp container-management/templates/docker-compose.secure.yml docker-compose.yml
          fi

          mkdir -p k8s
          if [ ! -f k8s/deployment.yaml ]; then
            echoe "No k8s/deployment.yaml found → creating secure template"
            cp container-management/templates/k8s-deployment.secure.yaml k8s/deployment.yaml
          fi

          if [ "${BASE_IMAGE_UPDATE}" = "true" ]; then
            echoe "Updating common base images to pinned versions"
            for f in $(ls -1 Dockerfile* 2>/dev/null || true); do
              echoe "  - patching ${f}"
              sed -i 's/\<alpine:latest\>/alpine:3.19/g' "$f" || true
              sed -i 's/\<ubuntu:latest\>/ubuntu:22.04/g' "$f" || true
              sed -i 's/\<node:latest\>/node:18-alpine/g' "$f" || true
              sed -i 's/\<python:latest\>/python:3.11-alpine/g' "$f" || true
              sed -i 's/\<nginx:latest\>/nginx:1.25-alpine/g' "$f" || true
            done
          fi

          RPT="container-management/reports/update-report-$(date +%Y%m%d).md"
          echoe "Writing update report: ${RPT}"
          cat > "${RPT}" <<EOR
          # Container File Update Report

          **Generated:** ${TS_UTC}
          **Update Type:** ${UPDATE_TYPE}
          **Base Image Update:** ${BASE_IMAGE_UPDATE}

          ## Changes Made
          - Dockerfile hardening (multi-stage, non-root, healthchecks)
          - Compose security options, healthchecks, secrets
          - K8s securityContext, probes, resource limits

          ## Next Steps
          1) Review & test locally
          2) Stage deploy & observe
          3) Schedule recurring scans
          EOR

          echoe "Update process completed"
          SH
          chmod +x container-management/tools/update-containers.sh

          echoe "Executing update script"
          UPDATE_TYPE="${{ env.UPDATE_TYPE }}" \
          BASE_IMAGE_UPDATE="${{ env.BASE_IMAGE_UPDATE }}" \
          bash container-management/tools/update-containers.sh

      - name: Security scanning (echo)
        if: env.SECURITY_SCAN == 'true'
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Writing security scanner"
          cat > container-management/tools/security-scanner.sh <<'SH'
          #!/usr/bin/env bash
          set -Eeuo pipefail
          source /tmp/echo_helpers.sh
          TS_UTC=$(TS)
          RPT="container-management/reports/security-scan-$(date +%Y%m%d).json"
          echoe "Start security scan @ ${TS_UTC}"

          cat > "${RPT}" <<JSON
          { "scan_metadata": { "timestamp": "${TS_UTC}", "scanner": "container-security-scanner", "scan_type": "dockerfile_analysis" },
            "scanned_files": [], "security_findings": [], "recommendations": [], "summary": { "total_files": 0, "critical_issues": 0, "high_issues": 0, "medium_issues": 0, "low_issues": 0 } }
          JSON

          count=0
          while IFS= read -r -d '' f; do
            count=$((count+1))
            echoe "Scanning $f"
            # simple checks
            grep -qE '^FROM .*:latest' "$f" && echoe "  ⚠ latest tag: $f" && true
            grep -qE '^USER ' "$f" || echoe "  ⚠ missing USER (non-root): $f"
            grep -qE '^HEALTHCHECK ' "$f" || echoe "  ⚠ missing HEALTHCHECK: $f"
            grep -qE '^ADD http' "$f" && echoe "  ⚠ ADD with URL: $f" || true
          done < <(find . -name "Dockerfile*" -type f -print0)

          jq --arg c "$count" '.summary.total_files = ($c|tonumber)' "${RPT}" > tmp.$$.json && mv tmp.$$.json "${RPT}"
          echoe "Security scan finished (files=$count) → ${RPT}"
          SH
          chmod +x container-management/tools/security-scanner.sh
          ./container-management/tools/security-scanner.sh

      - name: Generate comprehensive report (echo)
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Generating comprehensive report"
          TS_UTC=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          REPORT_FILE="container-management/reports/comprehensive-report-$(date +%Y%m%d).md"

          DOCKERFILES=$(find . -name "Dockerfile*" -type f | wc -l | tr -d ' ')
          COMPOSEFILES=$(find . \( -name "docker-compose*.yml" -o -name "docker-compose*.yaml" \) | wc -l | tr -d ' ')
          K8SFILES=$(find . \( -path "*/k8s/*" -o -path "*/kubernetes/*" \) -name "*.yaml" -o -name "*.yml" | wc -l | tr -d ' ')
          HELMCHARTS=$(find . -name "Chart.yaml" | wc -l | tr -d ' ')

          cat > "$REPORT_FILE" <<EOF
          # Container File Management Comprehensive Report

          **Generated:** ${TS_UTC}  
          **Update Type:** ${{ env.UPDATE_TYPE }}  
          **Base Image Update:** ${{ env.BASE_IMAGE_UPDATE }}  
          **Security Scan:** ${{ env.SECURITY_SCAN }}  
          **Registry:** ${{ env.REGISTRY }}  

          ## Summary
          - Dockerfiles: ${DOCKERFILES}
          - Docker Compose: ${COMPOSEFILES}
          - Kubernetes Manifests: ${K8SFILES}
          - Helm Charts: ${HELMCHARTS}

          ## Directory Structure
          \`\`\`
          container-management/
          ├── tools/
          ├── templates/
          ├── configs/
          ├── reports/
          ├── updates/
          └── backups/
          \`\`\`

          ## Recommendations
          1. Review generated files
          2. Test security improvements
          3. Apply CI scanning on PRs
          4. Monitor runtime health and resources
          EOF
          echoe "Report ready: ${REPORT_FILE}"

      - name: Update .gitignore for container management (echo)
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Updating .gitignore"
          {
            echo ""
            echo "# Container management files"
            echo "container-management/backups/"
            echo "container-management/temp/"
            echo "container-management/**/*.log"
            echo "container-management/**/*.tmp"
          } >> .gitignore
          echoe ".gitignore updated"

      - name: Create pull request (echo)
        if: env.CREATE_PR == 'true'
        uses: peter-evans/create-pull-request@v6
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: |
            feat: update container files with security enhancements

            - Multi-stage Dockerfiles, non-root, healthchecks
            - Secure docker-compose (no-new-privileges, caps, tmpfs)
            - K8s securityContext, probes, resources
            - Base images pinned where applicable
            - Reports & scans (echo-logged)

            Update Type: ${{ env.UPDATE_TYPE }}
            Registry: ${{ env.REGISTRY }}
            Security Scan: ${{ env.SECURITY_SCAN }}
          title: "🐳 Container Files Security Update - ${{ env.UPDATE_TYPE }}"
          body: |
            ## Container Files Update Summary

            Automated updates with enhanced security configurations.

            ### Update Details
            - **Update Type:** ${{ env.UPDATE_TYPE }}
            - **Base Image Update:** ${{ env.BASE_IMAGE_UPDATE }}
            - **Security Scan:** ${{ env.SECURITY_SCAN }}
            - **Registry:** ${{ env.REGISTRY }}

            ### Security Improvements
            1. Non-root user execution
            2. Read-only root filesystem (where applicable)
            3. Health checks for services
            4. Resource limits/requests
            5. Secrets and safer capabilities
            6. Pinned base images

            ### Testing Checklist
            - [ ] Build containers
            - [ ] Run integration tests
            - [ ] Validate probes/healthchecks
            - [ ] Review resource usage

            _Generated with echo logging across all steps._
          branch: feature/container-security-update-${{ github.run_number }}
          delete-branch: true
          labels: |
            containers
            security
            docker
            kubernetes
            automated

      - name: Commit remaining changes (no PR path) (echo)
        if: env.CREATE_PR != 'true'
        run: |
          source "${{ steps.echo_helpers.outputs.helpers }}"
          echoe "Committing changes directly"
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          git add -A
          if git diff --staged --quiet; then
            warn "No changes to commit"
          else
            git commit -m "feat: container file mgmt + security updates (echo)
            Update Type: ${{ env.UPDATE_TYPE }}
            Base Image Update: ${{ env.BASE_IMAGE_UPDATE }}
            Security Scan: ${{ env.SECURITY_SCAN }}
            Registry: ${{ env.REGISTRY }}"
            git push
            echoe "Pushed commit"
          fi
